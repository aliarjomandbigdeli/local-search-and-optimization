import java.util.ArrayList;
import java.util.LinkedList;
import java.util.Random;


/**
 * A genetic algorithm (or GA) is a variant of stochastic beam search in which successor states
 * are generated by combining two parent states rather than by modifying a single state.
 * <p>
 * GA begins with a set of k randomly generated states, called the population.
 * There are lots of versions for GA implementation based on
 */
public class GeneticAlgorithm {
    private Problem problem;
    private int populationSize;
    private LinkedList<State> population;
    private int tournamentSize;
    private LinkedList<State> parents;
    private double mutationRate;
    private int numberOfGenerations;
    private int numberOfCrossoverPoint;
    private State answer;

    private ArrayList<Double> bestFitnessOfGenerations;
    private ArrayList<Double> avgFitnessOfGenerations;
    private ArrayList<Double> worstFitnessOfGenerations;

    public GeneticAlgorithm(Problem problem, int populationSize, int tournamentSize,
                            double mutationRate, int numberOfGenerations, int numberOfCrossoverPoint) {
        this.problem = problem;
        this.populationSize = populationSize;
        this.tournamentSize = tournamentSize;
        this.mutationRate = mutationRate;
        this.numberOfGenerations = numberOfGenerations;
        this.numberOfCrossoverPoint = numberOfCrossoverPoint;

        bestFitnessOfGenerations = new ArrayList<>();
        worstFitnessOfGenerations = new ArrayList<>();
        avgFitnessOfGenerations = new ArrayList<>();
    }

    public GeneticAlgorithm(Problem problem, int populationSize,
                            int tournamentSize, double mutationRate, int numberOfGenerations) {
        this(problem, populationSize, tournamentSize,
                mutationRate, numberOfGenerations, 1);


    }

    public State getAnswer() {
        return answer;
    }

    public ArrayList<Double> getBestFitnessOfGenerations() {
        return bestFitnessOfGenerations;
    }

    public ArrayList<Double> getAvgFitnessOfGenerations() {
        return avgFitnessOfGenerations;
    }

    public ArrayList<Double> getWorstFitnessOfGenerations() {
        return worstFitnessOfGenerations;
    }

    public Problem getProblem() {
        return problem;
    }

    private void initializePopulation() {
        population = new LinkedList<>();
        for (int i = 0; i < populationSize; i++) {
            population.add(problem.generateRandomState());
        }
    }

    /**
     * tournament selection or parent selection
     * it select the best chromosome form tournamentSize that were chosen randomly
     */
    private void tournamentSelection() {
        parents = new LinkedList<>();
        int num = populationSize / tournamentSize;
        int[] choices = new int[tournamentSize];
        Random random = new Random();
        for (int i = 0; i < num; i++) {
            for (int j = 0; j < tournamentSize; j++) {
                choices[j] = random.nextInt(populationSize);
            }
            parents.add(population.get(bestChoice(choices)));
        }
    }

    /**
     * this method return best choice(chromosome) based on fitness function
     *
     * @param choices set of chromosome indices
     * @return
     */
    private int bestChoice(int[] choices) {
        int bestChoice = 0;
        for (int choice : choices) {
            if (problem.fitness(population.get(choice)) >
                    problem.fitness(population.get(bestChoice))) {
                bestChoice = choice;
            }
        }
        return bestChoice;
    }

    /**
     * this generate new generation from population
     *
     * @return new generation
     */
    private LinkedList<State> newGeneration() {
        LinkedList<State> newGeneration = new LinkedList<>();
        Random random = new Random();
        for (int i = 0; i < populationSize; i++) {
            int x = random.nextInt(parents.size());
            int y = random.nextInt(parents.size());
            while (x == y) {
                y = random.nextInt(parents.size());
            }
            newGeneration.add(problem.crossover(parents.get(x), parents.get(y), numberOfCrossoverPoint));
        }
        return newGeneration;
    }


    /**
     * this method select k number of genomes of all genomes in the generation to mutate
     *
     * @param generation input generation
     * @return mutated generation
     */
    private LinkedList<State> mutation(LinkedList<State> generation) {
        Random random = new Random();
        int mutatedGenomes = ((Double) (populationSize * problem.getNumberOfGenomes() * mutationRate)).intValue();
        for (int i = 0; i < mutatedGenomes; i++) {
            problem.mutation(generation.get(random.nextInt(generation.size())),
                    random.nextInt(problem.getNumberOfGenomes()));
        }
        return generation;
    }

    /**
     * run the algorithm
     */
    public void execute() {
        initializePopulation();
        calculateFitnessOfGeneration();
        for (int i = 0; i < numberOfGenerations; i++) {
            tournamentSelection();
            LinkedList<State> newGeneration = newGeneration();
            mutation(newGeneration);
            population = newGeneration;
            calculateFitnessOfGeneration();
        }
        answer = population.get(0);
        for (State state : population) {
            if (problem.fitness(state) > problem.fitness(answer)) {
                answer = state;
            }
        }
    }

    /**
     * this method store best, worst and average fitness of a generation
     */
    private void calculateFitnessOfGeneration() {
        double best = problem.fitness(population.get(0));
        double worst = problem.fitness(population.get(0));
        double sum = 0;
        double temp = 0;
        for (State state : population) {
            temp = problem.fitness(state);
            if (best < temp)
                best = temp;
            if (worst > temp)
                worst = temp;
            sum += temp;
        }
        bestFitnessOfGenerations.add(best);
        worstFitnessOfGenerations.add(worst);
        avgFitnessOfGenerations.add(sum / population.size());

    }
}
